# -*- coding: utf-8 -*-
"""Combat_Restructured_v0.04.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XQg0UrGAuKJ3FNVW3CvRSUqtHMJclHo3

# Table of Contents

Directory / package layout (future-proof)

playfantasia/
├─ core/                     # deterministic, 100 % unit-tested
│  ├─ combat/                # turn loop + in-fight state
│  │   ├─ combatant.py
│  │   ├─ formulas.py        # ONLY math lives here
│  │   ├─ skills.py          # runtime SkillHandle
│  │   ├─ effects.py         # runtime StatusEffect
│  │   └─ encounter.py
│  │
│  ├─ items/                 # PoE-style prefixes, suffixes, uniques
│  │   ├─ item.py            # ItemHandle
│  │   ├─ affix.py           # Affix record + roller
│  │   └─ modbus.py          # (+X to Y) aggregator
│  │
│  ├─ env/                   # global & room-level mutators
│  │   ├─ hazard.py          # lava tile, poison mist…
│  │   ├─ modifier.py        # “daily modifier: enemies +20 % speed”
│  │   └─ worldstate.py      # active list, tick hooks
│  │
│  └─ util/                  # seeded RNG, math helpers, small shared utils
│
├─ data/                     # designer-tuned YAML, DB rows
│  ├─ effects/*.yaml
│  ├─ skills/*.yaml
│  ├─ affixes.sqlite
│  ├─ uniques/*.yaml
│  └─ env/*.yaml
│
├─ samples/                  # quick-start notebooks & scripts
├─ tools/                    # CLI (linter, affix roller, replay viewer…)
└─ docs/                     # specs, mermaid diagrams

Who Talks To Who?

flowchart LR
    %% COMBAT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    subgraph COMBAT
        formulas -->|stat_query| combatant
        combatant -.-> encounter
        skills --> encounter
        effects --> encounter
        effects --> combatant
    end
    %% ITEMS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    subgraph ITEMS
        item --> combatant
        affix --> item
        modbus --> item
    end
    %% ENVIRONMENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    subgraph ENV
        env_mod(worldstate) --> encounter
        env_mod -.global_mod.-> modbus
    end
    %% DATA & UTIL (leaf nodes)
    util --> formulas

# Startup Script (Folder Create)
"""

# Commented out IPython magic to ensure Python compatibility.
# %%bash
# mkdir -p playfantasia

import textwrap, shutil
from pathlib import Path

# --- 1.  Where the project lives ------------------------------------------------
BASE = Path("/mnt/data/playfantasia")       # adjust if you prefer another root
if BASE.exists():
    shutil.rmtree(BASE)                     # start fresh when you rerun the cell
BASE.mkdir(parents=True)

# --- 2.  Directory tree ---------------------------------------------------------
DIRS = [
    BASE / "core" / "combat",
    BASE / "core" / "items",
    BASE / "core" / "env",
    BASE / "core" / "util",
    BASE / "data" / "skills",
    BASE / "data" / "effects",
    BASE / "data" / "env",
    BASE / "samples",
    BASE / "docs",
    BASE / "tools",
]

for d in DIRS:
    d.mkdir(parents=True, exist_ok=True)

# --- 3.  Stub-file contents -----------------------------------------------------
stub = {}

# 3-A  package placeholders ------------------------------------------------------
for pkg in [
    BASE,
    BASE / "core",
    BASE / "core" / "combat",
    BASE / "core" / "items",
    BASE / "core" / "env",
    BASE / "core" / "util",
]:
    stub[pkg / "__init__.py"] = f'# Package placeholder for {pkg.relative_to(BASE)}\n'

# 3-B  combat layer --------------------------------------------------------------
stub[BASE/"core/combat/formulas.py"] = '"""Future combat math lives here."""\n'
stub[BASE/"core/combat/combatant.py"] = '"""Combatant class placeholder."""\n'
stub[BASE/"core/combat/skills.py"] = '"""SkillHandle placeholder."""\n'
stub[BASE/"core/combat/effects.py"] = '"""StatusEffect base goes here."""\n'
stub[BASE/"core/combat/encounter.py"] = '"""Turn loop / speed queue placeholder."""\n'

# 3-C  items layer ---------------------------------------------------------------
stub[BASE/"core/items/item.py"] = '"""ItemHandle placeholder."""\n'
stub[BASE/"core/items/affix.py"] = textwrap.dedent("""
    \"\"\"Affix record & roller (stub).\"\"\"
    class Affix: pass
""")
stub[BASE/"core/items/modbus.py"] = textwrap.dedent("""
    \"\"\"ModBus aggregator (stub).\"\"\"
    class ModBus:
        @staticmethod
        def aggregate(source, target):
            return {}
""")

# 3-D  environment layer ---------------------------------------------------------
stub[BASE/"core/env/worldstate.py"] = textwrap.dedent("""
    \"\"\"Global environmental effects (stub).\"\"\"
    class WorldState:
        active_mods = []
        def tick(self, dt): pass
""")
stub[BASE/"core/env/modifier.py"] = textwrap.dedent("""
    \"\"\"EnvModifier placeholder.\"\"\"
    class EnvModifier:
        tags = ()
        flat_mods = {}
        mult_mods = {}
        duration = None
        def apply(self, encounter): pass
        def remove(self, encounter): pass
""")

# 3-E  util helpers --------------------------------------------------------------
stub[BASE/"core/util/random.py"] = textwrap.dedent("""
    \"\"\"Seeded RNG helper (stub).\"\"\"
    import random
    def rng(seed=None):
        return random.Random(seed)
""")

# 3-F  sample runner & docs placeholders ----------------------------------------
stub[BASE/"samples/README.md"] = "# Sample notebooks will appear here\n"
stub[BASE/"docs/architecture.mmd"] = "<!-- mermaid diagram placeholder -->\n"
stub[BASE/"tools/README.md"] = "# CLI utilities go here\n"

# --- 4.  Write all files --------------------------------------------------------
for path, content in stub.items():
    path.write_text(content)

# --- 5.  Pretty-print the resulting tree ---------------------------------------
def tree(path: Path, prefix: str = ""):
    entries = sorted(path.iterdir())
    for i, p in enumerate(entries):
        connector = "└── " if i == len(entries)-1 else "├── "
        print(prefix + connector + p.name)
        if p.is_dir():
            extension = "    " if i == len(entries)-1 else "│   "
            tree(p, prefix + extension)

print("Project scaffold created at", BASE, "\n")
tree(BASE)

"""# Combat Engine

## Encounter.py
"""

import textwrap, pathlib, datetime, random, inspect, os

file_path = pathlib.Path("/mnt/data/playfantasia/core/combat/encounter.py")

encounter_code = textwrap.dedent(
    '''
    """playfantasia.core.combat.encounter
    ====================================
    A **CombatEncounter** owns the battle loop.  It is intentionally dumb:
    •  It knows *who* is fighting and in what order they act (initiative).
    •  It calls each combatant's chosen SkillHandle.
    •  It advances cooldowns and status‑effects.
    •  It records ActionResult objects so the UI / test harness can replay.

    Everything else – formulas, skill details, status effect behaviour – lives
    in their dedicated modules.  That keeps this file small and easy to audit.
    """

    from __future__ import annotations

    # -------------------------------------------------------------------- #
    # Std‑lib
    # -------------------------------------------------------------------- #
    import random
    from dataclasses import dataclass, field
    from typing import List, Dict, Any, Optional

    # -------------------------------------------------------------------- #
    # Internal imports
    # -------------------------------------------------------------------- #
    from playfantasia.core.combat.combatant import Combatant
    from playfantasia.core.combat.skills import select_first_ready, SkillHandle, ActionResult
    # Encounter deliberately does NOT import effects or formulas directly.


    # -------------------------------------------------------------------- #
    # Helper: simple initiative roll
    # In future we'll move to a full speed queue, but for now we roll once at
    # battle start and keep that fixed order.
    # -------------------------------------------------------------------- #
    def _roll_initiative(combatants: List[Combatant], rnd) -> List[Combatant]:
        """Return a new list sorted descending by DEX, tie‑broken randomly."""
        # snapshot so we don't mutate caller order
        order = list(combatants)
        # Sort by (DEX, random float) descending
        order.sort(key=lambda c: (c.total_stats().get("DEX", 0), rnd.random()), reverse=True)
        return order


    # -------------------------------------------------------------------- #
    # Battle log – small wrapper around list[ActionResult]
    # -------------------------------------------------------------------- #
    @dataclass(slots=True)
    class BattleLog:
        rounds: List[List[ActionResult]] = field(default_factory=list)

        def add_round(self, actions: List[ActionResult]):
            self.rounds.append(actions)

        def as_dict(self) -> Dict[str, Any]:
            return {"rounds": [[a.as_dict() for a in r] for r in self.rounds]}

        def __str__(self):
            out = []
            for i, rnd in enumerate(self.rounds, 1):
                out.append(f"===== Round {i} =====")
                for action in rnd:
                    if not action.hit:
                        out.append(f"{action.actor}'s {action.skill_used} MISSED {action.target}")
                    else:
                        crit = " CRIT!" if action.crit else ""
                        out.append(f"{action.actor} used {action.skill_used} on {action.target} "
                                   f"for {action.damage} dmg{crit}")
            return "\\n".join(out)


    # -------------------------------------------------------------------- #
    # CombatEncounter
    # -------------------------------------------------------------------- #
    @dataclass(slots=True)
    class CombatEncounter:
        """Container that drives the fight until one side is wiped out."""

        combatants: List[Combatant]
        rng_seed: int = 42  # deterministic by default

        # these fields are initialised in __post_init__
        rng: random.Random = field(init=False, repr=False)
        initiative: List[Combatant] = field(init=False, repr=False)

        def __post_init__(self):
            self.rng = random.Random(self.rng_seed)
            # Give each combatant the same RNG (substream) for consistency
            for c in self.combatants:
                c.rng = self.rng
            self.initiative = _roll_initiative(self.combatants, self.rng)

        # ---------------------------------------------------------------- #
        def run_battle(self) -> BattleLog:
            """Loop rounds until only one faction (for now: last man standing)."""
            log = BattleLog()

            round_idx = 0
            while self._count_alive() > 1 and round_idx < 99:  # hard cap to avoid inf loops
                round_idx += 1
                actions_this_round: List[ActionResult] = []

                for actor in self.initiative:
                    if not actor.is_alive:
                        continue  # dead before their turn
                    # 1. Start‑of‑turn effects tick
                    actor.tick_effects()
                    if not actor.is_alive:
                        continue  # DOT might have killed them

                    # 2. Pick a target – simplest: first alive enemy
                    target = self._pick_target(actor)
                    if target is None:
                        continue  # no enemies left

                    # 3. Choose a skill (AI placeholder)
                    skill = select_first_ready(self._get_hotbar(actor))

                    # 4. Execute
                    result = skill.execute(actor, target, self, self.rng)
                    actions_this_round.append(result)

                    # 5. Tick cooldowns for ALL skills in actor's bar
                    for s in self._get_hotbar(actor):
                        s.tick_cd()

                    # Early exit if battle ended mid‑round
                    if self._count_alive() <= 1:
                        break

                log.add_round(actions_this_round)

            return log

        # ---------------------------------------------------------------- #
        # Helper – naive: everyone fights everyone (no team logic yet)
        # ---------------------------------------------------------------- #
        def _pick_target(self, actor: Combatant) -> Optional[Combatant]:
            for c in self.combatants:
                if c is not actor and c.is_alive:
                    return c
            return None

        # ---------------------------------------------------------------- #
        def _get_hotbar(self, actor: Combatant) -> List[SkillHandle]:
            """Placeholder: attach skills list if not already set."""
            hb = getattr(actor, "hotbar", None)
            if hb is None:
                # Lazy create: BasicAttack only
                from playfantasia.core.combat.skills import BasicAttack, PowerStrike
                actor.hotbar = [PowerStrike(), BasicAttack()]
            return actor.hotbar

        # ---------------------------------------------------------------- #
        def _count_alive(self) -> int:
            return sum(1 for c in self.combatants if c.is_alive)
    '''
)

file_path.parent.mkdir(parents=True, exist_ok=True)
file_path.write_text(encounter_code)

print(f"Generated {file_path}")

"""## Formulas.py"""

# Path to the formulas.py file in the new scaffold
import textwrap, pathlib, json, os, sys, importlib, pprint, inspect, datetime, math

file_path = pathlib.Path("/mnt/data/playfantasia/core/combat/formulas.py")

# Content of the regenerated formulas.py with extensive lay‑man comments
formulas_code = textwrap.dedent(
    """
    """
PlayFantasia • formulas.py
Pure maths – no game objects.
"""

from __future__ import annotations
import math
import random

__all__ = [
    # secondary
    "sec_hp", "sec_weapon_damage",
    # opposed helpers
    "sigmoid_opposed", "chance_to_hit", "chance_to_crit",
    # damage
    "raw_damage", "mitigation", "final_damage",
]

# ──────────────────────────────────────────────────────────────
# 1.  Secondary attributes
# ──────────────────────────────────────────────────────────────
def sec_hp(CON: int) -> int:
    return CON * 10

def sec_weapon_damage(wpn_dmg: int, STR: int = 0, INT: int = 0,
                      dmg_type: str = "physical") -> float:
    stat = STR if dmg_type == "physical" else INT
    return wpn_dmg + 0.5 * stat


# ──────────────────────────────────────────────────────────────
# 2.  Generic opposed-stat logistic curve
# ──────────────────────────────────────────────────────────────
def sigmoid_opposed(att: float, deff: float,
                    *, base=5.0, ceiling=95.0, k=0.15) -> float:
    """Bounded logistic curve used for all opposed rolls."""
    return base + (ceiling - base) / (1 + math.exp(-k * (att - deff)))


# Convenience RNG so tests can seed deterministically
_rng: random.Random = random.Random()
def set_seed(seed: int | None) -> None: _rng.seed(seed)


# ──────────────────────────────────────────────────────────────
# 3.  Chances
# ──────────────────────────────────────────────────────────────
def chance_to_hit(att_stats: dict, def_stats: dict) -> float:
    return sigmoid_opposed(
        att_stats.get("DEX", 0) + att_stats.get("AGI", 0),
        def_stats.get("AGI", 0),
    )

def chance_to_crit(att_stats: dict, def_stats: dict) -> float:
    return sigmoid_opposed(
        att_stats.get("DEX", 0),
        def_stats.get("AGI", 0),
    )


# ──────────────────────────────────────────────────────────────
# 4.  Damage pipeline
# ──────────────────────────────────────────────────────────────
def raw_damage(att_stats: dict, dmg_type: str = "physical") -> float:
    base = att_stats.get("weapon_damage", 0)
    STR, INT = att_stats.get("STR", 0), att_stats.get("INT", 0)
    return base + 0.5 * (STR if dmg_type == "physical" else INT)

def mitigation(def_stats: dict, dmg_type: str = "physical") -> float:
    if dmg_type == "physical":
        return def_stats.get("armor", 0) * 0.25
    if dmg_type == "magical":
        return def_stats.get("resist", 0) * 0.30
    return 0  # true dmg

def final_damage(att_stats: dict, def_stats: dict, dmg_type="physical") -> int:
    dmg = raw_damage(att_stats, dmg_type) - mitigation(def_stats, dmg_type)
    return max(1, int(dmg))

    """
)

# Ensure parent directory exists
file_path.parent.mkdir(parents=True, exist_ok=True)

# Write the regenerated code to the file
file_path.write_text(formulas_code)

# For user visibility, print the path and a small snippet of the file
print(f"Regenerated {file_path}")
print("-" * 60)
print("\\n".join(formulas_code.splitlines()[:40]))

"""## Skills.py"""

import textwrap, pathlib, inspect

file_path = pathlib.Path("/mnt/data/playfantasia/core/combat/skills.py")

skills_code_corrected = textwrap.dedent(
    '''
    """playfantasia.core.combat.skills
    =================================
    *SkillHandle* objects are how the encounter tells a combatant to perform a
    single action.  Each instance owns its **cooldown counter**, is able to say
    "I am ready" or "Still recharging", and — when executed — returns an
    *ActionResult* that the logger can serialise or print.

    In the long term every concrete skill will migrate into data templates, but
    we keep two hard‑coded examples here so the battle loop has something to
    call while the template compiler is not yet written.
    """

    from __future__ import annotations

    # ──────────────────────────────────────────────────────────────────────
    # Standard library
    # ──────────────────────────────────────────────────────────────────────
    from dataclasses import dataclass, field
    from typing import Any, Dict, TYPE_CHECKING, List

    # ──────────────────────────────────────────────────────────────────────
    # Internal imports (only low‑level helpers; avoid circular deps)
    # ──────────────────────────────────────────────────────────────────────
    from playfantasia.core.combat import formulas
    from playfantasia.core.util.random import rng_bool
    from playfantasia.core.combat.combatant import Combatant

    if TYPE_CHECKING:
        from playfantasia.core.combat.encounter import CombatEncounter
        from playfantasia.core.combat.effects import StatusEffect

    # -------------------------------------------------------------------- #
    # ActionResult – tiny DTO returned by every skill execution
    # -------------------------------------------------------------------- #
    @dataclass(slots=True)
    class ActionResult:
        """
        A record of one action execution – whether it hit, crit, damage done,
        etc.  The battle logger or UI layer can turn this straight into text or
        animations.
        """
        actor: str
        target: str
        skill_used: str
        hit: bool = False
        crit: bool = False
        damage: int = 0   # post‑mitigation
        # placeholder for future: applied_effects: list[str] = field(default_factory=list)

        def as_dict(self) -> Dict[str, Any]:
            """Return a plain dict for easy JSON dumps."""
            return self.__dict__

    # -------------------------------------------------------------------- #
    # Base class – every concrete skill inherits from this
    # -------------------------------------------------------------------- #
    @dataclass(slots=True)
    class SkillHandle:
        """
        An object that lives in a combatant's hotbar.  It holds its own cooldown
        timer so the CombatEncounter can simply call `tick_cd()` on everyone at
        the end of a round.
        """
        name: str
        cooldown_max: int = 0
        current_cd: int = 0

        # ───────── Ready / cooldown helpers ───────── #
        def is_ready(self) -> bool:
            return self.current_cd == 0

        def tick_cd(self):
            if self.current_cd > 0:
                self.current_cd -= 1

        def reset_cd(self):
            """Set the timer back to full (called after a successful execute)."""
            self.current_cd = self.cooldown_max

        # ───────── Main API ───────── #
        def execute(
            self,
            actor: Combatant,
            target: Combatant,
            encounter: "CombatEncounter",
            rnd,
        ) -> ActionResult:
            """
            Sub‑classes override this.  They MUST call `self.reset_cd()` at the
            end so that future turns see the correct cooldown.
            """
            raise NotImplementedError

    # -------------------------------------------------------------------- #
    # Concrete sample 1: BasicAttack
    # -------------------------------------------------------------------- #
    class BasicAttack(SkillHandle):
        """
        Fallback physical hit that every unit can perform.  No cooldown.
        Damage = STR.  Uses hit and crit rolls from formulas.py.
        """
        def __init__(self):
            super().__init__(name="Basic Attack", cooldown_max=0)

        def execute(
            self,
            actor: Combatant,
            target: Combatant,
            encounter: "CombatEncounter",
            rnd,
        ) -> ActionResult:
            res = ActionResult(actor=actor.name, target=target.name, skill_used=self.name)

            # 1. Did we hit?
            if not formulas.hit_roll(
                actor.total_stats().get("ACC", 0),
                target.total_stats().get("EVA", 0),
                rnd,
            ):
                res.hit = False
                self.reset_cd()  # basic attack still "spends" the action
                return res

            res.hit = True

            # 2. Base damage starts at STR
            dmg = actor.total_stats().get("STR", 1)

            # 3. Crit check
            if formulas.crit_roll(actor.total_stats().get("CRT", 0), rnd):
                res.crit = True
                dmg = int(dmg * formulas.crit_multiplier(actor.total_stats().get("STR", 0)))

            # 4. Target mitigates & loses HP
            res.damage = target.take_damage(dmg, "phys")

            self.reset_cd()
            return res

    # -------------------------------------------------------------------- #
    # Concrete sample 2: PowerStrike – shows a cooldown and self‑buff
    # -------------------------------------------------------------------- #
    class PowerStrike(SkillHandle):
        """200 % STR damage and applies a one‑turn Rage effect to self."""
        def __init__(self):
            super().__init__(name="Power Strike", cooldown_max=2)

        def execute(
            self,
            actor: Combatant,
            target: Combatant,
            encounter: "CombatEncounter",
            rnd,
        ) -> ActionResult:
            res = ActionResult(actor=actor.name, target=target.name, skill_used=self.name)
            res.hit = True  # guaranteed hit for demo purposes

            dmg = actor.total_stats().get("STR", 1) * 2
            if formulas.crit_roll(actor.total_stats().get("CRT", 0), rnd):
                res.crit = True
                dmg = int(dmg * formulas.crit_multiplier(actor.total_stats().get("STR", 0)))

            res.damage = target.take_damage(dmg, "phys")

            # Attempt to apply Rage if the effect class exists
            try:
                from playfantasia.core.combat.effects import Rage
                actor.apply_effect(Rage(source=actor))
            except (ImportError, AttributeError):
                pass  # Rage not implemented yet – safe in early scaffolding

            self.reset_cd()
            return res

    # -------------------------------------------------------------------- #
    # Helper – pick the first ready skill from a hotbar
    # -------------------------------------------------------------------- #
    def select_first_ready(hotbar: List[SkillHandle]) -> SkillHandle:
        """
        Utility for simple AI: iterate the list in order, return the first skill
        whose cooldown is 0.  If none are ready, return a new BasicAttack().
        """
        for s in hotbar:
            if s.is_ready():
                return s
        return BasicAttack()
    '''
)

file_path.parent.mkdir(parents=True, exist_ok=True)
file_path.write_text(skills_code_corrected)

print(f"Generated {file_path}")

"""## Effects.py"""

import textwrap, pathlib, sys, os, json, inspect, datetime, math

file_path = pathlib.Path("/mnt/data/playfantasia/core/combat/effects.py")

effects_code = textwrap.dedent(
    '''
    """playfantasia.core.combat.effects
    ==================================
    **StatusEffect** objects are the long‑lived buffs, debuffs and damage‑over‑
    time instances that stick to a Combatant between turns.

    Design goals
    ------------
    1.  *Deterministic*: no random rolls inside hooks – the encounter supplies
        the RNG, so replays are reproducible.
    2.  *Tiny Surface*: only three lifecycle hooks (`on_apply`, `on_tick`,
        `on_remove`) so designers / code reviewers have a fixed mental model.
    3.  *Stacking Rules*: a single `StackRule` enum covers 95 % of RPG needs.
    4.  *No Dependencies Upwards*: this file never imports `encounter` or
        `skills` – keeping our layered architecture clean.
    """

    from __future__ import annotations

    # --------------------------------------------------------------------- #
    # Std‑lib imports
    # --------------------------------------------------------------------- #
    from dataclasses import dataclass, field
    from enum import Enum, auto
    from typing import Dict, TYPE_CHECKING, Any

    if TYPE_CHECKING:
        from playfantasia.core.combat.combatant import Combatant

    # --------------------------------------------------------------------- #
    # StackRule – how re‑application behaves
    # --------------------------------------------------------------------- #
    class StackRule(Enum):
        """What happens if the same effect tag is applied again."""
        REFRESH = auto()     # Keep one instance → reset duration
        STACK_ADD = auto()   # Add independent copy (common for DoTs)
        STACK_MERGE = auto() # Merge into one; increment .stacks
        REJECT = auto()      # Ignore new application entirely

    # --------------------------------------------------------------------- #
    # Base class
    # --------------------------------------------------------------------- #
    @dataclass(slots=True)
    class StatusEffect:
        """
        The superclass every concrete effect inherits from.  Most fields are
        **data only**; the three hook methods contain the behaviour.
        """

        # Core identity
        tag: str                           # dot.poison, buff.rage …
        duration: int                      # turns remaining
        source: 'Combatant'                # who cast / applied it

        # Stacking behaviour
        stack_rule: StackRule = StackRule.REFRESH
        stacks: int = 1
        max_stacks: int = 1

        # Power knobs – subclasses populate these
        magnitude: int = 0                 # generic "strength" number
        flat_mods: Dict[str, int] = field(default_factory=dict)
        mult_mods: Dict[str, float] = field(default_factory=dict)

        # ---------------------------------------------------------------- #
        # Lifecycle hooks – default to no‑op so subclasses implement only
        # what they need.
        # ---------------------------------------------------------------- #
        def on_apply(self, target: 'Combatant') -> None:
            """Called **once** when the effect is first attached."""
            pass

        def on_tick(self, target: 'Combatant') -> None:
            """
            Called at the *start* of the affected combatant's turn.
            The encounter decrements `duration` afterwards.
            """
            pass

        def on_remove(self, target: 'Combatant') -> None:
            """Called when duration hits zero or effect is forcibly dispelled."""
            pass


    # --------------------------------------------------------------------- #
    # Concrete example effects
    # --------------------------------------------------------------------- #
    class PoisonDOT(StatusEffect):
        """
        Classic damage‑over‑time that scales with the caster's INT and refreshes
        on re‑application.
        """
        BASE_PCT = 0.15  # 15 % of caster INT per tick

        def __init__(self, source: 'Combatant', duration: int = 2):
            super().__init__(
                tag="dot.poison",
                duration=duration,
                source=source,
                stack_rule=StackRule.REFRESH,
            )

        def on_apply(self, target: 'Combatant'):
            caster_int = self.source.total_stats().get("INT", 0)
            self.magnitude = max(1, int(caster_int * self.BASE_PCT))

        def on_tick(self, target: 'Combatant'):
            # True damage – ignores armour
            target.take_damage(self.magnitude, dmg_type="true")

    # --------------------------------------------------------------------- #
    class Shield(StatusEffect):
        """
        Flat armour boost that *merges* on re‑apply (higher duration wins).
        """
        def __init__(self, source: 'Combatant', duration: int = 2):
            super().__init__(
                tag="buff.shield",
                duration=duration,
                source=source,
                stack_rule=StackRule.STACK_MERGE,
                max_stacks=1,
            )

        def on_apply(self, target: 'Combatant'):
            bonus = int(self.source.total_stats().get("INT", 0) * 0.4)
            # Store so we can undo exactly the same amount on_remove
            self.flat_mods = {"ARM": bonus}

        def on_remove(self, target: 'Combatant'):
            # Nothing special: flat_mods automatically vanish when Combatant
            # removes the effect from its list.
            pass

    # --------------------------------------------------------------------- #
    class Rage(StatusEffect):
        """
        +50 % STR, −10 % ACC for 1 turn.  Refreshes rather than stacks.
        """
        def __init__(self, source: 'Combatant', duration: int = 1):
            super().__init__(
                tag="buff.rage",
                duration=duration,
                source=source,
                stack_rule=StackRule.REFRESH,
            )

        def on_apply(self, target: 'Combatant'):
            # multiplicative buffs are percentage (0.5 = +50 %)
            self.mult_mods = {
                "STR": 0.5,     # +50 % strength
                "ACC": -0.1,    # −10 % accuracy
            }

    # --------------------------------------------------------------------- #
    # Public factory mapping for quick look‑ups (useful for templates later)
    # --------------------------------------------------------------------- #
    EFFECT_REGISTRY: Dict[str, type[StatusEffect]] = {
        "dot.poison": PoisonDOT,
        "buff.shield": Shield,
        "buff.rage": Rage,
    }
    '''
)

file_path.parent.mkdir(parents=True, exist_ok=True)
file_path.write_text(effects_code)

print(f"Generated {file_path}")

"""## Combatant.py"""

import textwrap, pathlib, datetime, inspect, sys, os, json, math


# Path to combatant.py
file_path = pathlib.Path("/mnt/data/playfantasia/core/combat/combatant.py")

combatant_code = textwrap.dedent(
    """
    \"\"\"playfantasia.core.combat.combatant
    =====================================

    The **Combatant** class is the heart of a single entity inside the battle
    simulation (player, monster, summoned minion …).  It owns its stats, gear,
    active status‐effects and current HP  – *but it knows nothing about* turn
    order or how an encounter progresses.  That orchestration lives in
    `core.combat.encounter`.

    Why separate things this way?
        •  Keeping Combatant self‑contained means we can unit‑test damage maths
           without spinning up a whole battle.
        •  Encounter can iterate a list[Combatant] generically; it doesn’t care
           whether a unit is a goblin or the player’s wizard.

    ---------------------------------------------------------------------------
    TL;DR of public interface
    ---------------------------------------------------------------------------
    •  `.total_stats()` – aggregated view (base + gear + effects).
    •  `.take_damage(raw, *, dtype='phys')` – apply mitigation, subtract HP,
       return *post‑mitigation* damage actually done (for the log).
    •  `.heal(amount)` – bounded by max HP.
    •  `.apply_effect(StatusEffect)` – resolves stacking rules and stores it.
    •  `.tick_effects()` – call once per turn; triggers DOT, decrements timers.
    •  Properties: `.hp`, `.is_alive`, `.max_hp`, `.name`.
    \"\"\"

    from __future__ import annotations

    # ----------------------------------------------------------------------- #
    # Std‑lib & typing
    # ----------------------------------------------------------------------- #
    from dataclasses import dataclass, field
    from typing import Dict, List, TYPE_CHECKING, Any, Optional

    # ----------------------------------------------------------------------- #
    # Internal imports – note: only things **below** Combatant in dependency
    # tree get imported here (formulas, util.random).  We do NOT import
    # 'skills' or 'encounter' to avoid circular deps.
    # ----------------------------------------------------------------------- #
    from playfantasia.core.combat import formulas
    from playfantasia.core.util.random import rng_bool  # used for flee rolls etc.

    # Forward‑refs to avoid circular import at type‑check time.
    if TYPE_CHECKING:
        from playfantasia.core.combat.effects import StatusEffect
        from playfantasia.core.items.item import Item


    # ----------------------------------------------------------------------- #
    # Designer‑facing list of canonical stat keys.
    # Every system that needs a stat should pull from this set so we never end
    # up with “STR” vs “Strength” bugs.
    # ----------------------------------------------------------------------- #
    STAT_KEYS: tuple[str, ...] = (
        "STR",   #  Strength          – adds to crit multiplier / melee dmg
        "DEX",   #  Dexterity         – might feed dodge later
        "INT",   #  Intelligence      – spell scaling
        "ACC",   #  Accuracy          – hit chance
        "EVA",   #  Evasion           – dodge chance
        "CRT",   #  Critical Rate     – crit chance
        "ARM",   #  Armor             – flat damage mitigation
        "HP",    #  Maximum hit‑points
    )


    # ----------------------------------------------------------------------- #
    # Helper: tiny additive container for gear stats so we don’t write the
    # same comprehension three times.
    # ----------------------------------------------------------------------- #
    def _sum_item_stats(items: List["Item"]) -> Dict[str, int]:
        total: Dict[str, int] = {}
        for itm in items:
            for k, v in getattr(itm, "stat_bonus", {}).items():
                total[k] = total.get(k, 0) + v
        return total


    # ----------------------------------------------------------------------- #
    # Combatant – **runtime** entity used by the encounter loop.
    # ----------------------------------------------------------------------- #
    @dataclass(slots=True)
    class Combatant:
        \"\"\"A creature or character that can act in combat.\"\"\"

        # ─────────────────────────────────────────────────────────────────── #
        # Basic identity
        # ─────────────────────────────────────────────────────────────────── #
        name: str

        # ─────────────────────────────────────────────────────────────────── #
        # Core stats – base values defined by archetype or level‑up table.
        # Example: {"STR": 10, "DEX": 6, "INT": 2, ...}
        # (We *do not* enforce all keys present – missing keys treated as 0.)
        # ─────────────────────────────────────────────────────────────────── #
        base_stats: Dict[str, int] = field(default_factory=dict)

        # ─────────────────────────────────────────────────────────────────── #
        # Skills the combatant can use
        # ─────────────────────────────────────────────────────────────────── #
        hotbar: List["SkillHandle"] = field(default_factory=list) # Add this line

        # ─────────────────────────────────────────────────────────────────── #
        # Equipped items (weapon, armour …).  Each item is expected to expose
        # a `.stat_bonus` dict and later a `contributing_mods()` for ModBus.
        # ─────────────────────────────────────────────────────────────────── #
        equipment: List["Item"] = field(default_factory=list, repr=False)

        # ─────────────────────────────────────────────────────────────────── #
        # Current HP – starts at max_hp unless a scenario spawns a wounded unit.
        # ─────────────────────────────────────────────────────────────────── #
        hp: int = -1  # Will be initialised in __post_init__

        # ─────────────────────────────────────────────────────────────────── #
        # Active status effects (buffs/debuffs).  Populated at runtime.
        # ─────────────────────────────────────────────────────────────────── #
        active_effects: List["StatusEffect"] = field(default_factory=list, repr=False)

        # A local RNG for things like flee chance; seeded by encounter.
        rng: Any = field(default=None, repr=False)

        # ------------------------------------------------------------------ #
        # Dataclass post‑init hook – sets HP to max if caller left it at -1.
        # ------------------------------------------------------------------ #
        def __post_init__(self):
            if self.hp == -1:
                self.hp = self.max_hp

        # ------------------------------------------------------------------ #
        # Properties
        # ------------------------------------------------------------------ #
        @property
        def max_hp(self) -> int:
            \"\"\"Dynamic because buffs or gear can raise HP mid‑fight.\"\"\"
            return self.total_stats().get("HP", 1)

        @property
        def is_alive(self) -> bool:
            return self.hp > 0

        # ------------------------------------------------------------------ #
        # Core public methods
        # ------------------------------------------------------------------ #
        def total_stats(self) -> Dict[str, int]:
            \"\"\"Return a fresh **dict** combining base + gear + effect mods.

            1. Start with *base_stats*.
            2. Add any `stat_bonus` from equipped items.
            3. Add each effect's **flat_mods**.
            4. Apply each effect's **mult_mods** (multiplicative).
            \"\"\"
            totals: Dict[str, float] = dict(self.base_stats)

            # 1+2: equipment
            gear_bonus = _sum_item_stats(self.equipment)
            for k, v in gear_bonus.items():
                totals[k] = totals.get(k, 0) + v

            # 3: flat additive buffs/debuffs
            for eff in self.active_effects:
                for k, v in getattr(eff, "flat_mods", {}).items():
                    totals[k] = totals.get(k, 0) + v

            # 4: multiplicative (order‑independent because we multiply factors)
            for eff in self.active_effects:
                for k, m in getattr(eff, "mult_mods", {}).items():
                    totals[k] = totals.get(k, 0) * (1 + m)

            # Cast everything back to int for downstream math
            return {k: int(v) for k, v in totals.items()}

        # ------------------------------------------------------------------ #
        def take_damage(self, raw: int, dmg_type: str = "physical") -> int:
                """Apply armour / resist mitigation, subtract HP and
                return the **actual** damage taken.

                The attacker has already produced a raw‐damage number.
                We now let `formulas.mitigation()` translate our own stats
                into a flat reduction, then make sure at least 1 HP lands.
                """
                # `total_stats()` gives our aggregated dictionary of stats
                reduction = formulas.mitigation(self.total_stats(), dmg_type)
                dealt     = max(1, int(raw - reduction))

                self.hp = max(0, self.hp - dealt)
                return dealt

        # ------------------------------------------------------------------ #
        def heal(self, amount: int) -> int:
            \"\"\"Restore HP, never exceeding max_hp. Returns real amount healed.\"\"\"
            if amount <= 0 or not self.is_alive:
                return 0
            before = self.hp
            self.hp = min(self.max_hp, self.hp + amount)
            return self.hp - before

        # ------------------------------------------------------------------ #
        # Status‑effect plumbing
        # ------------------------------------------------------------------ #
        def apply_effect(self, effect: "StatusEffect"):
            \"\"\"Handle stacking rules then add the *effect* instance.

            For now we simply append; the real stacking/refresh logic will be
            coded in `effects.py`.  This keeps Combatant tiny and dumb.
            \"\"\"
            from playfantasia.core.combat.effects import StackRule  # local import

            # Quick path: no effect with same tag yet → just add
            same = next((e for e in self.active_effects if e.tag == effect.tag), None)
            if same is None:
                self.active_effects.append(effect)
                effect.on_apply(self)
                return

            # Respect chosen stacking policy
            if effect.stack_rule == StackRule.REFRESH:
                same.duration = effect.duration
                same.magnitude = max(same.magnitude, effect.magnitude)
            elif effect.stack_rule == StackRule.STACK_ADD:
                self.active_effects.append(effect)
                effect.on_apply(self)
            elif effect.stack_rule == StackRule.STACK_MERGE:
                same.stacks = min(same.stacks + 1, getattr(same, "max_stacks", 1))
                same.duration = effect.duration
            # STACK_RULE.REJECT does nothing

        # ------------------------------------------------------------------ #
        def tick_effects(self):
            \"\"\"Call at *start of this combatant’s turn*.\"\"\"
            for eff in list(self.active_effects):  # copy → we might remove
                eff.on_tick(self)
                eff.duration -= 1
                if eff.duration <= 0:
                    eff.on_remove(self)
                    self.active_effects.remove(eff)

        # ------------------------------------------------------------------ #
        # Debug helper – pretty string
        # ------------------------------------------------------------------ #
        def __str__(self):
            return f\"{self.name} (HP {self.hp}/{self.max_hp})\"
    """
)

# Ensure path exists
file_path.parent.mkdir(parents=True, exist_ok=True)
file_path.write_text(combatant_code)

print(f"Wrote {file_path}")
print("-" * 60)
print("\\n".join(combatant_code.splitlines()[:60]))

"""# Util

## Random.py
"""

# The state reset removed earlier context, need to write file again
import textwrap, pathlib, random, os, sys

file_path = pathlib.Path("/mnt/data/playfantasia/core/util/random.py")
file_path.parent.mkdir(parents=True, exist_ok=True)

random_code = textwrap.dedent("""
\"\"\"playfantasia.core.util.random
================================
Single choke‑point wrapper around Python’s `random.Random`.

Why bother?

*  **Deterministic replays** – Gameplay passes in a seeded Random so we can
   reproduce battles bit‑for‑bit.
*  **Easy future swap** – If we need a faster RNG or PCG32, we update one file.

Only two helpers are exposed for now: `rng_bool` and `rng_float`.
\"\"\"

from __future__ import annotations
import random
from typing import Any

# ---------------------------------------------------------------------------#
# Public helpers
# ---------------------------------------------------------------------------#
def rng_bool(rnd: \"random.Random\", p: float) -> bool:
    \"\"\"Return *True* with probability **p** (0 ≤ p ≤ 1).\"\"\"
    if p <= 0.0:
        return False
    if p >= 1.0:
        return True
    return rnd.random() < p


def rng_float(rnd: \"random.Random\", a: float, b: float) -> float:
    \"\"\"Uniform float in the closed range [a, b].\"\"\"
    return rnd.uniform(a, b)


# ---------------------------------------------------------------------------#
# Emergency global RNG (non‑deterministic).  Gameplay logic should **not**
# rely on this; it's only for dev tools or colourful debug prints.
# ---------------------------------------------------------------------------#
DEFAULT_RNG = random.Random()
""")

file_path.write_text(random_code)
print(f"Wrote {file_path}")

"""# Battle Runner"""

import textwrap
import pathlib
import datetime
import random
import inspect
import os
import sys
import importlib
import importlib.util
import types # Import types module

# Ensure the top-level directory is treated as a package
BASE_PATH = "/mnt/data/playfantasia"
init_file = pathlib.Path(BASE_PATH) / "__init__.py"
if not init_file.exists():
    init_file.write_text("# Package placeholder for playfantasia\n")

# Ensure the playfantasia package is in the sys.path
if BASE_PATH not in sys.path:
    sys.path.append(BASE_PATH)

# --- FIX: Explicitly create and load parent packages and modules using importlib ---

# Define paths to the key modules
formulas_path = pathlib.Path(BASE_PATH) / 'core' / 'combat' / 'formulas.py' # Need formulas too now
combatant_path = pathlib.Path(BASE_PATH) / 'core' / 'combat' / 'combatant.py'
encounter_path = pathlib.Path(BASE_PATH) / 'core' / 'combat' / 'encounter.py'
effects_path = pathlib.Path(BASE_PATH) / 'core' / 'combat' / 'effects.py'

# Define the module names
base_package_name = 'playfantasia'
core_package_name = 'playfantasia.core'
combat_package_name = 'playfantasia.core.combat'
formulas_module_name = 'playfantasia.core.combat.formulas'
combatant_module_name = 'playfantasia.core.combat.combatant'
encounter_module_name = 'playfantasia.core.combat.encounter'
effects_module_name = 'playfantasia.core.combat.effects'

try:
    # 1. Create and add parent packages to sys.modules
    if base_package_name not in sys.modules:
        sys.modules[base_package_name] = types.ModuleType(base_package_name)
        sys.modules[base_package_name].__path__ = [str(pathlib.Path(BASE_PATH))] # Essential for packages

    if core_package_name not in sys.modules:
        sys.modules[core_package_name] = types.ModuleType(core_package_name)
        sys.modules[core_package_name].__path__ = [str(pathlib.Path(BASE_PATH) / 'core')]

    if combat_package_name not in sys.modules:
        sys.modules[combat_package_name] = types.ModuleType(combat_package_name)
        sys.modules[combat_package_name].__path__ = [str(pathlib.Path(BASE_PATH) / 'core' / 'combat')]


    # 2. Load the individual modules in dependency order
    # Load formulas module (dependency for combatant)
    spec_formulas = importlib.util.spec_from_file_location(formulas_module_name, formulas_path)
    if spec_formulas is None:
         raise ImportError(f"Could not create spec for {formulas_module_name} at {formulas_path}")
    formulas_module = importlib.util.module_from_spec(spec_formulas)
    sys.modules[formulas_module_name] = formulas_module
    spec_formulas.loader.exec_module(formulas_module)
    # Access the formulas module
    formulas = formulas_module
    print(f"Successfully loaded {formulas_module_name}")

    # Load effects module (dependency for Combatant)
    spec_effects = importlib.util.spec_from_file_location(effects_module_name, effects_path)
    if spec_effects is None:
         raise ImportError(f"Could not create spec for {effects_module_name} at {effects_path}")
    effects_module = importlib.util.module_from_spec(spec_effects)
    sys.modules[effects_module_name] = effects_module
    spec_effects.loader.exec_module(effects_module)
    # Access the StatusEffect class for type hints in Combatant
    StatusEffect = effects_module.StatusEffect
    print(f"Successfully loaded {effects_module_name}")

    # Load Combatant module (depends on formulas and effects)
    spec_combatant = importlib.util.spec_from_file_location(combatant_module_name, combatant_path)
    if spec_combatant is None:
         raise ImportError(f"Could not create spec for {combatant_module_name} at {combatant_path}")
    combatant_module = importlib.util.module_from_spec(spec_combatant)
    sys.modules[combatant_module_name] = combatant_module
    # Make sure dependencies are available in sys.modules before executing
    # We already added them above, but this is a good sanity check
    if formulas_module_name not in sys.modules:
         raise ImportError(f"Dependency {formulas_module_name} not found in sys.modules for {combatant_module_name}")
    if effects_module_name not in sys.modules:
         raise ImportError(f"Dependency {effects_module_name} not found in sys.modules for {combatant_module_name}")

    spec_combatant.loader.exec_module(combatant_module)
    Combatant = combatant_module.Combatant
    print(f"Successfully loaded {combatant_module_name}")

    # Load Encounter module (depends on Combatant and skills - skills not loaded yet, but Encounter.py handles lazy import)
    # Encounter also depends on effects, but it does NOT import it directly according to its docstring.
    # However, Combatant *does* import effects, and Encounter imports Combatant.
    # This confirms our loading order (effects -> Combatant -> Encounter) is correct.
    spec_encounter = importlib.util.spec_from_file_location(encounter_module_name, encounter_path)
    if spec_encounter is None:
         raise ImportError(f"Could not create spec for {encounter_module_name} at {encounter_path}")
    encounter_module = importlib.util.module_from_spec(spec_encounter)
    sys.modules[encounter_module_name] = encounter_module
     # Make sure Combatant dependency is available
    if combatant_module_name not in sys.modules:
         raise ImportError(f"Dependency {combatant_module_name} not found in sys.modules for {encounter_module_name}")
    spec_encounter.loader.exec_module(encounter_module)
    CombatEncounter = encounter_module.CombatEncounter
    print(f"Successfully loaded {encounter_module_name}")


except ImportError as e:
    print(f"--- IMPORT ERROR ---")
    print(f"Error importing playfantasia modules: {e}")
    print("Please ensure the project structure is correctly set up and the BASE_PATH is correct.")
    print(f"Current sys.path: {sys.path}")
    print(f"Does {combatant_path} exist? {combatant_path.exists()}")
    print(f"Does {pathlib.Path(BASE_PATH) / 'core' / '__init__.py'} exist? {(pathlib.Path(BASE_PATH) / 'core' / '__init__.py').exists()}")
    # Re-raise the exception to see the standard traceback
    raise

# --- End FIX ---


# --- Create Combatants ---
# You can adjust names, base_stats, and max_hp here
fighter_stats = {"STR": 15, "DEX": 10, "INT": 5, "ACC": 12, "EVA": 8, "CRT": 5, "ARM": 10, "HP": 100}
goblin_stats = {"STR": 8, "DEX": 12, "INT": 3, "ACC": 10, "EVA": 15, "CRT": 2, "ARM": 5, "HP": 60}

# Note: max_hp is now calculated within the Combatant class's __post_init__
# based on the HP stat in base_stats, so you don't need to pass it explicitly.
# If you *do* pass it, it will override the calculated value.
player = Combatant(name="Hero", base_stats=fighter_stats)
goblin = Combatant(name="Goblin", base_stats=goblin_stats)

# --- Create and Run Encounter ---
# You can change the seed for a different battle outcome
battle = CombatEncounter(combatants=[player, goblin], rng_seed=123)

print("Starting battle simulation...\n")

battle_log = battle.run_battle()

print("\nBattle simulation finished.")

# --- Print Battle Log ---
print("\n--- Battle Log ---")
print(battle_log)

# --- Final Status ---
print("\n--- Final Status ---")
print(f"{player.name}: HP = {player.hp}/{player.max_hp}, Alive = {player.is_alive}")
print(f"{goblin.name}: HP = {goblin.hp}/{goblin.max_hp}, Alive = {goblin.is_alive}")